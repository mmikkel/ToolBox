/** * ... * @author Mats Mikkel Rummelhoff * Created January 14th, 2010 * Copyright 2010. All rights reserved. * http://www.matsmikkel.net */package no.mmikkel.utils {		import flash.display.*;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.external.ExternalInterface;	import flash.geom.*;	import flash.net.*;	import flash.system.*;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;	import flash.xml.*;
		public class ToolBox {				private static const VERSION:String = "0.3.3";				/* LOGGER */		// Log to Javascript console (also traces in IDE). Set ToolBox.doLog = true to activate		static public var doLog:Boolean = false;		static public var doTrace:Boolean = true;		public static function log(...rest):void {			if(doLog || doTrace){				var s:String = "Log >> "+rest.join(" ");				if(doLog && ExternalInterface.available){					ExternalInterface.call("console.log",s);				}				if(doTrace){					trace(s);				}			}		}				/* NUMERIC FUNCTIONS */		// Limit the number of decimals in a number. The Number class has a toFixed() method that does this, but it uses string manipulation which is slower than a clean numeric method.		public static function limitDecimals(number:Number,numDecimals:Number=2):Number		{			return Math.round(Math.pow(10,numDecimals)*number)/Math.pow(10,numDecimals);		}		// Get a random number between two numbers		public static function randomNumberBetween(low:Number,high:Number,round:Boolean=false):Number {			return Math.floor(Math.random() * (1+high-low)) + low;  		}		// Calculates the difference between two numbers		public static function getNumberDifference(n1:Number,n2:Number):Number {			var diff:Number = n1 - n2;			if(diff < 0){				diff *= -1;			}			return diff;		}		// Convert seconds to a typical timer format (HH:MM:SS)		public static function getFormattedTime(seconds:int):String {			var timeOut:String = '';			var hours:int = int( seconds / 3600 );			var mins:int = int( ( seconds - ( hours * 3600 ) ) / 60 )			var secs:int = seconds % 60;			if( isNaN( hours ) || isNaN( mins ) || isNaN( secs ) ) {				return "--:--:--";			}			var hourS:String = ( hours < 10 ) ? "0" + hours : String( hours );			var minS:String = ( mins < 10 ) ? "0" + mins : String( mins );			var secS:String = ( secs < 10 ) ? "0" + secs : String( secs );			if(hours > 0){				timeOut = hourS+':';			}			timeOut += minS + ":" + secS;			return timeOut;		}		// Get a two-value gradient from a hex color		public static function makeGradient(color:uint,intensity:int=20,toDarkerShade:Boolean=true):Array	    {			var color2:uint;	        if(toDarkerShade){				color2 = getDarkerShade(color,intensity);			} else {				color2 = getLighterShade(color,intensity);			}	        return [color,color2];	    }		// The following color methods were stolen/adapted from http://www.veryinteractivepeople.com/?p=323		// Get a darker shade from a hex code		public static function getDarkerShade(hexColor:Number,percent:Number=50):Number{            if(isNaN(percent))                percent=0;            if(percent>100)                percent=100;            if(percent<0)                percent=0;            var factor:Number=1-(percent/100);            var rgb:Object=hexToRGB(hexColor);            rgb.r*=factor;            rgb.b*=factor;            rgb.g*=factor;            return RGBToHex(Math.round(rgb.r),Math.round(rgb.g),Math.round(rgb.b));        }		// Get a lighter shade from a hex code		public static function getLighterShade(hexColor:Number,percent:Number=50):Number{            if(isNaN(percent))                percent=0;            if(percent>100)                percent=100;            if(percent<0)                percent=0;            var factor:Number=percent/100;            var rgb:Object=hexToRGB(hexColor);            rgb.r+=(255-rgb.r)*factor;            rgb.b+=(255-rgb.b)*factor;            rgb.g+=(255-rgb.g)*factor;            return RGBToHex(Math.round(rgb.r),Math.round(rgb.g),Math.round(rgb.b));        }		// Get the hex code from RGB values		public static function RGBToHex(r:Number, g:Number, b:Number):Number {                return(r<<16 | g<<8 | b);        }		// Get the RGB values from a hex code        public static function hexToRGB (hex:Number):Object{            return {r:(hex & 0xff0000) >> 16,g:(hex & 0x00ff00) >> 8,b:hex & 0x0000ff};        }       	// Hex code to integer		public static function hexToInt(s:String):int		{			if(s.indexOf("#") > -1){				s = s.split("#").join("");			}			return int("0x"+s);		}		// integer to hex code		public static function intToHex(c:uint):String {			var r:String=((c>>16)&0xFF).toString(16).toUpperCase();			var g:String=((c>>8)&0xFF).toString(16).toUpperCase();			var b:String=(c&0xFF).toString(16).toUpperCase();			var hs:String="";			var zero:String="0";			if(r.length==1){			r=zero.concat(r);			}			if(g.length==1){			g=zero.concat(g);			}			if(b.length==1){			b=zero.concat(b);			}			hs=r+g+b;			return hs;		}				/* STRING FUNCTIONS */		// Validate an email address		public static function validateEmail(str:String):Boolean {			var pattern:RegExp = /(\w|[_.\-])+@((\w|-)+\.)+\w{2,4}+/;			var result:Object = pattern.exec(str);			if (result == null) {				return false;			}			return true;		}		// Strip all whitespace and trailing		public static function trimWhiteSpace(theString:String):String {			theString =  theString.split("\r").join("");			theString =  theString.split("\t").join("");			while ( theString.indexOf("  " ) != -1 ) {				theString= theString.split("  ").join(" ");			}			if (theString.substr(0,1) == " ") {				theString = theString.substr( 1 );			}			if (theString.substr( theString.length-1, 1 ) == " ") {				theString = theString.substr( 0, theString.length - 1 );			}			return( theString );		}		// Capitalize a string. Optionally keep the rest of the string's formatting intact (useful with names etc)		public static function capitalize(phrase:String,keepFormatting:Boolean=false):String { 				if(!keepFormatting){					phrase = phrase.toLowerCase();				}				var wordArr:Array = phrase.split(" ");				var phraseArr:Array = new Array();				for(var i:int = 0;i<wordArr.length;++i){					var word:String = wordArr[i] as String;					switch(word) { 						case "and": 						case "the": 						case "in": 						case "an": 						case "or": 						case "at": 						case "of": 						case "a": 							// Don't do anything to these words. 							break; 						default: 							// For any other word, capitalize the first character. 							var firstLetter:String = word.substr(0, 1); 							firstLetter = firstLetter.toUpperCase(); 							var otherLetters:String = word.substring(1); 							word = firstLetter + otherLetters; 					}					phraseArr.push(word);				}				phrase = phraseArr.join(" ");				return phrase;		}		// Convert a string to something a browser wont choke on		static public function URLFriendlyString(_url:String):String {			var url:String = _url;			url = url.toLowerCase();			url = url.split(" ").join("-");			url = url.replace(/¿/,"o");  			url = url.replace(/Œ/,"a");  			url = url.replace(/¾/,"ae");  			return url;		}		// Works in tandem with the former; converts the string back to its former state		static public function contentFriendlyString(_url:String,_capitalize:Boolean = true,delimiter:String = " / "):String {			var url:String = "";			var urlArr:Array = _url.split("/");			var aL:int = urlArr.length;			for(var i:int = 0;i<aL;++i){				var phrase:String = urlArr[i].split("-").join(" ");				if(_capitalize) {					phrase = capitalize(phrase);				}				url += phrase;				if(i > 0 && i < aL-1){					url += delimiter;				}			}			return url;		}		// Retrieve the URL of the embedded SWF		public static function getCurrentURL():String {			var url:String = ExternalInterface.call("window.location.href.toString");			return url;		}		// Retrieve the domain of the embedded SWF		public static function getCurrentDomain():String {			var url:String = ExternalInterface.call("window.location.hostname.toString");			return url;		}		// Strip HTML tags		public static function stripTags(value:String):String		{			var removeHtmlRegExp:RegExp = new RegExp("<[^<]+?>", "gi");			return value.replace(removeHtmlRegExp, "");		}		// Convert to UTF-8		public static function toUTF8(value:String):String		{			var utftext:String = "";	 		for(var n:int = 0;n<value.length;++n) {	 			var c:Number = value.charCodeAt(n);	 			if (c < 128) {					utftext += String.fromCharCode(c);				}				else if((c > 127) && (c < 2048)) {					utftext += String.fromCharCode((c >> 6) | 192);					utftext += String.fromCharCode((c & 63) | 128);				}				else {					utftext += String.fromCharCode((c >> 12) | 224);					utftext += String.fromCharCode(((c >> 6) & 63) | 128);					utftext += String.fromCharCode((c & 63) | 128);				}			}	 		return utftext;		}				/* DISPLAY OBJECT FUNCTIONS */		// Remove all of a DisplayObject's children		public static function flush(mc:*):void {			mc = mc as DisplayObject;			if(mc.numChildren != 0) {				var i:int = mc.numChildren;				while(i--) {					mc.removeChildAt(i);				}			}		}		// Center a DisplayObject		public static function center(mc:*,target:*,_x:Boolean=true,_y:Boolean=true,round:Boolean=true,offsetX:Number=0,offsetY:Number=0,regcenter:Boolean=false):void		{			var w:Number;			var h:Number;			if(!(target is Stage)){				w = target.width;				h = target.height;			} else {				w = target.stageWidth;				h = target.stageHeight;			}			if(_x){				mc.x = (w - mc.width) * .5;				mc.x += offsetX;				if(regcenter){					mc.x += (mc.width * .5);				}				if(round){					mc.x = Math.round(mc.x);				}			}			if(_y){				mc.y = (h - mc.height) * .5;				mc.y += offsetY;				if(regcenter){					mc.y += (mc.height * .5);				}				if(round){					mc.y = Math.round(mc.y);				}			}		}		// Draw a rectangle		public static function doDrawRect(w:Number,h:Number,color:int = 0x000000,alpha:Number = 0):Shape {			var square:Shape = new Shape();            square.graphics.beginFill(color,alpha);            square.graphics.drawRect(0, 0, w, h);            square.graphics.endFill();            return square;		}		// Draw a gradient-filled rectangle. Rotation of the gradient is given in degrees, not radians		public static function doDrawGradientRect(type:String="",width:Number=100,height:Number=100,rotation:Number=0,colors:Array=null,alphas:Array=null,ratios:Array=null,offsetX:Number=0,offsetY:Number=0,lineColor:Number=-1,lineThickness:Number=1,lineAlpha:Number=1):Shape		{			if(type == ""){				type = GradientType.LINEAR;			}			colors = colors ? colors : [0x0,0xFFFFFF];			alphas = alphas ? alphas : [1,1];			ratios = ratios ? ratios : [0,255];			var shape:Shape = new Shape();			var gfx:Graphics = shape.graphics;			if(lineColor > -1){				gfx.lineStyle(lineThickness,lineColor,lineAlpha,true);			} else {				//gfx.lineStyle(1,0x0,0,true);			}			var matrix:Matrix = new Matrix();			rotation = (Math.PI/180)*rotation; // Convert to radians			matrix.createGradientBox(width,height,rotation,offsetX,offsetY);			gfx.beginGradientFill(type,colors,alphas,ratios,matrix);			gfx.drawRect(0,0,width,height);			gfx.endFill();			return shape;		}		// Draw a rounded rectangle. Graphics.curveTo() provides smoother and more precise corners than Graphics.drawRoundRect		public static function doDrawRoundedRect(width:Number=100,height:Number=100,radius:Number=40,color:Number=0x0,alpha:Number=1):Shape {			var shape:Shape = new Shape();			var gfx:Graphics = shape.graphics;			gfx.beginFill(color,alpha);			gfx.moveTo(radius, 0);			gfx.lineTo(width - radius, 0);			gfx.curveTo(width, 0, width, radius);			gfx.lineTo(width, radius);			gfx.lineTo(width, height - radius);			gfx.curveTo(width, height, width - radius, height);			gfx.lineTo(width - radius, height);			gfx.lineTo(radius, height);			gfx.curveTo(0, height, 0, height - radius);			gfx.lineTo(0, height - radius);			gfx.lineTo(0, radius);			gfx.curveTo(0, 0, radius, 0);			gfx.lineTo(radius, 0);			gfx.endFill();			return shape;		}		// Draw a gradient-filled, rounded rectangle. Rotation of the gradient is given in degrees, not radians		public static function doDrawRoundedGradientBox(type:String="linear",width:Number=100,height:Number=100,radius:Number=40,rotation:Number=0,colors:Array=null,alphas:Array=null,ratios:Array=null,offsetX:Number=0,offsetY:Number=0,lineColor:Number=-1,lineThickness:Number=1):Shape		{			colors = colors ? colors : [0x0,0xFFFFFF];			alphas = alphas ? alphas : [1,1];			ratios = ratios ? ratios : [0,255];			var shape:Shape = new Shape();			var gfx:Graphics = shape.graphics;			if(lineColor > -1){				gfx.lineStyle(lineThickness,lineColor,1,true);			} else {				gfx.lineStyle(1,0x0,0,true);			}			var matrix:Matrix = new Matrix();			rotation = (Math.PI/180)*rotation; // Convert to radians			matrix.createGradientBox(width,height,rotation,offsetX,offsetY);			gfx.beginGradientFill(type,colors,alphas,ratios,matrix);			gfx.moveTo(radius, 0);			gfx.lineTo(width - radius, 0);			gfx.curveTo(width, 0, width, radius);			gfx.lineTo(width, radius);			gfx.lineTo(width, height - radius);			gfx.curveTo(width, height, width - radius, height);			gfx.lineTo(width - radius, height);			gfx.lineTo(radius, height);			gfx.curveTo(0, height, 0, height - radius);			gfx.lineTo(0, height - radius);			gfx.lineTo(0, radius);			gfx.curveTo(0, 0, radius, 0);			gfx.lineTo(radius, 0);			gfx.endFill();			return shape;		}		// Get the visible height of a DisplayObject. Useful if the DO contains masked objects warping its height property. Take note: Quite slow		public static function getVisibleHeight (o:DisplayObject):Number {			var bitmapDataSize:int = 2000;			var bounds:Rectangle;			var bitmapData:BitmapData = new BitmapData(bitmapDataSize, 													 bitmapDataSize,													 true,													 0);			bitmapData.draw(o);			bounds = bitmapData.getColorBoundsRect( 0xFF000000, 0x00000000, false );			bitmapData.dispose(); 			return bounds.y + bounds.height;		}		// Get the visible width of a DisplayObject. Useful if the DO contains masked objects warping its width property. Take note: Quite slow		public static function getVisibleWidth (o:DisplayObject):Number {			var bitmapDataSize:int = 2000;			var bounds:Rectangle;			var bitmapData:BitmapData = new BitmapData(bitmapDataSize, 													 bitmapDataSize, 													 true, 													 0);			bitmapData.draw(o);			bounds = bitmapData.getColorBoundsRect( 0xFF000000, 0x00000000, false );			bitmapData.dispose(); 			return bounds.x + bounds.width;		}		// Get the class of of any object		public static function getClass(obj:Object):Class {			return ApplicationDomain.currentDomain.getDefinition(getQualifiedClassName(obj)) as Class;		}		// Convert a DisplayObject to a Bitmap		public static function mcToBitmap(mc:*,transparent:Boolean=true,color:Number=0xFFFFFF,smoothing:Boolean=true,offsetX:int=0,offsetY:int=0):Bitmap		{			mc = mc as DisplayObject;			var bmData:BitmapData = new BitmapData(mc.width,mc.height,transparent,color);			bmData.draw(mc); //draw contents of sprite to bitmpData			var bitmap:Bitmap = new Bitmap(bmData);			bitmap.smoothing = smoothing;			return bitmap;		}				/* ARRAY FUNCTIONS */		public static function randomizeArray(a:Array):Array {			var tempArr:Array = new Array();			while(a.length > 0) {				tempArr.push(a.splice(Math.round(Math.random() * (a.length - 1)), 1)[0]);			}			return tempArr;		}		// Merge any number of arrays. Removes duplicates		public static function mergeArrays(...args):Array		{			var array:Array = new Array;			for(var i:int = 0;i<args.length;++i){ // Check if the array is... an array				if(!(args[i] is Array)){					continue;				}				for(var j:int = 0;j<args[i].length;++j){ // Add all the values of the array to the end array					if(array.indexOf(args[i][j]) == -1){						array.push(args[i][j]);					}				}			}			return array;		}		// Merge any number of arrays. Does not remove duplicates		public static function mergeArraysWithDuplicates(...args):Array		{			var array:Array = new Array;			for(var i:int = 0;i<args.length;++i){ // Check if the array is... an array				if(!(args[i] is Array)){					continue;				}				for(var j:int = 0;j<args[i].length;++j){ // Add all the values of the array to the end array					array.push(args[i][j]);				}			}			return array;		}		// Count the number of times an element appears in an array		public static function countInArray(a:Array,value:*):int		{			var count:int = 0;			var aL:int = a.length;			for(var i:int = 0;i<aL;++i){				var aValue:* = a[i];				if(aValue == value){					count++;				}			}			return count;		}		/// return a single element at random from the given array		public static function randomElement(a:Array):*		{			return a[Math.round(Math.random() * (a.length - 1))];		}				// NEW:		public static function getArrayIndex(a:Array,value:*):Number		{			var aL:int = a.length;			for(var i:int = 0;i<aL;++i){				if(a[i] == value){					return i;				}			}			return -1;		}		public static function getObjectLength(o:Object):uint		{			var len:uint = 0;			for (var item:* in o)				if (item != "mx_internal_uid")					len++;			return len;		}		public static function loadImageFile(src:String,container:*,preloader:*,cache:Boolean=false,callBack:Function=null,errorHandler:Function=null,context:LoaderContext=null):void		{			var loader:Loader = new Loader();			loader.contentLoaderInfo.addEventListener(Event.COMPLETE,loadCompleteHandler);			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,loadErrorHandler);			var request:URLRequest = new URLRequest(src);			if(Capabilities.playerType != "External" && !cache) {				var header:URLRequestHeader = new URLRequestHeader("pragma", "no-cache");				request.requestHeaders.push(header);				request.method = URLRequestMethod.GET;				request.data = new URLVariables("time="+Number(new Date().getTime()))			}			try{				loader.load(request,context);			} catch(error:Error){				doError();			}			function loadCompleteHandler(e:Event):void			{				try{					var bitmap:Bitmap = e.target.content as Bitmap;					bitmap.smoothing = true;					container.addChild(bitmap);				} catch(e:Error){					doError();				}				doCallBack();				close();			}			function loadErrorHandler(e:Event):void			{				doError();				close();			}			function doError():void			{				if(errorHandler != null){					errorHandler();				}			}			function doCallBack():void			{				if(callBack != null){					callBack();				}			}			function close():void			{				loader.contentLoaderInfo.removeEventListener(Event.COMPLETE,loadCompleteHandler);				loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR,loadErrorHandler);				}		}			}	}